# Step 3: Plot scatter points and SD1/SD2 ellipses for each epoch
for epoch in sorted(unique_epochs):
    visible = dataset.active_epochs[epoch]

    # Create a boolean mask for the current epoch
    mask = (epochs == epoch)[:-1]  # Ensure alignment with x and y arrays

    # Scatter plot for current epoch
    scatter = ax.scatter(x[mask], y[mask], label=epoch.title(), alpha=0.25)
    scatter_handles[epoch] = scatter

    # Compute SD1 and SD2 for the current epoch
    _sd1 = np.std(np.subtract(x[mask], y[mask]) / np.sqrt(2))  # Perpendicular to line of identity
    _sd2 = np.std(np.add(x[mask], y[mask]) / np.sqrt(2))       # Along the line of identity
    ibm = np.mean(x[mask])  # Mean IBI
    col = scatter.get_facecolor()  # Color of the scatter points

    # Create an ellipse to represent SD1 and SD2 variability
    ellipse = Ellipse(
        (ibm, ibm), _sd1 * 2, _sd2 * 2, angle=-45,
        linewidth=2, zorder=1, facecolor=col, edgecolor=col
    )
    ax.add_artist(ellipse)
    ellipse_handles[epoch] = ellipse

    # Set visibility based on 'active_epochs'
    scatter.set_visible(visible)
    ellipse.set_visible(visible)

# Step 4: Add hover functionality using mplcursors
cursor = mplcursors.cursor(list(scatter_handles.values()), highlight=True, hover=False)

def on_hover(sel):
    """
    Display epoch and time information on hover.

    Args:
        sel: The cursor selection event triggered by hovering.
    """
    scatter_idx = list(scatter_handles.values()).index(sel.artist)
    epoch = list(scatter_handles.keys())[scatter_idx]

    # Retrieve the point index directly from the scatter data
    point_idx = sel.index
    sel.annotation.set_text(
        f"{epoch}\nTime: {round(times[point_idx], 2)}"
    )

cursor.connect("add", on_hover)
